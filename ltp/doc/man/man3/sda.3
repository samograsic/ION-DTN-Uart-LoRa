.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.42)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "pod3::sda 3"
.TH pod3::sda 3 "2022-10-13" "perl v5.34.0" "LTP library functions"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
sda \- LTP Service Data Aggregation (SDA) library
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    #include "sda.h"
\&
\&    typedef vast (*SdaDelimiterFn)(unsigned int clientId, unsigned char *buffer, vast bufferLength);
\&
\&    typedef int (*SdaHandlerFn)(uvast sourceEngineId, unsigned int clientId, Object clientServiceData);
\&
\&    [see description for available functions]
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The \fBsda\fR library provides functions enabling application software to use \s-1LTP\s0
more efficiently, by aggregating multiple small client service data units
into larger \s-1LTP\s0 client service data items.  This reduces overhead somewhat,
but more importantly it reduces the volume of positive and negative \s-1LTP\s0
acknowledgment traffic by sending more data in fewer \s-1LTP\s0 blocks \*(-- because
\&\s-1LTP\s0 acknowledgments are issued on a per-block basis.
.PP
The library relies on the application to detect the boundaries between
aggregated service data units in each received \s-1LTP\s0 client service data item;
the application must provide an SdaDelimiterFn function for this purpose.  An
\&\s-1SDA\s0 delimiter function inspects the client service data bytes in \fIbuffer\fR \-
some portion of an \s-1LTP\s0 service data block, of length \fIbufferLength\fR \- to
determine the length of the client service data unit at the start of the
buffer; data unit client service \s-1ID\s0 is provided to aid in this determination.
The function returns that length if the determination was successful, zero
if there is no valid client service data item at the start of the buffer, \-1
on any system failure.
.PP
The \fBsda\fR library similarly relies on the application to process the service
data units identified in this manner; the application must provide an
SdaHandlerFn function for this purpose.  An \s-1SDA\s0 handler function is provided
with the \s-1ID\s0 of the \s-1LTP\s0 engine that sent the service data unit, the client
\&\s-1ID\s0 characterizing the service data unit, and the service data unit itself;
the service data unit is presented as a Zero-Copy Object (\s-1ZCO\s0).  The handler
function must return \-1 on any system error, zero otherwise.
.IP "int sda_send(uvast destinationEngineId, unsigned int clientId, Object clientServiceData);" 4
.IX Item "int sda_send(uvast destinationEngineId, unsigned int clientId, Object clientServiceData);"
Sends a client service data unit to an application, identified by \fIclientId\fR,
at the \s-1LTP\s0 engine identified by \fIdestinationEngineId\fR.  clientServiceData must
be a \*(L"zero-copy object\*(R" reference as returned by \fBionCreateZco()\fR.  Note that \s-1SDA\s0
will privately make and destroy its own reference to the client service data;
the application is free to destroy its reference at any time.   Note that the
client service data unit will always be sent reliably (i.e., \*(L"red\*(R").
.Sp
Also note that \fBsda_run()\fR must be executing in order for sda_send to be
performed.
.Sp
Returns 0 on success, \-1 on any system failure.
.IP "int sda_run(SdaDelimiterFn delimiter, SdaHandlerFn handler);" 4
.IX Item "int sda_run(SdaDelimiterFn delimiter, SdaHandlerFn handler);"
\&\fBsda_run()\fR executes an infinite loop that receives \s-1LTP\s0 client service data items,
calls \fIdelimiter\fR to determine the length of each client service data unit
in each item, and passes those client service data units to the \fIhandler\fR
function.  To terminate the loop, call \fBsda_interrupt()\fR.  Note that \fBsda_send()\fR
can only be executed while the \fBsda_run()\fR loop is still executing.
.Sp
Returns 0 on success, \-1 on any system failure.
.IP "void \fBsda_interrupt()\fR;" 4
.IX Item "void sda_interrupt();"
Interrupts \fBsda_run()\fR.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fBsdatest\fR\|(1), \fBzco\fR\|(3)
